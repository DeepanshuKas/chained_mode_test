# This module tests cluster report i.e (logs and status files depicting
# snapshot of the running cluster and CNI pods) generated using
# acikubectl binary using below command.
# `acikubectl debug cluster-report  --output=test.tar.gz`
# Test verifies existence of expected directories and files in test.tar.gz
# Test report failure in below 2 cases.
#     1) expected directories or files is not available in output
#        cluster report generated by acikubectl.
#     2) existence of files is verified but contents of files is empty
import os
import shutil
from acc_pyutils.api import KubeAPI
from acc_pyutils import logger
from tests import lib, lib_helper
from tests.common_utils import check_chained_mode
from tests.server_utils import ServerUtils


SRV_UTILS = ServerUtils()
EXEC_TIMEOUT = 240
LOG = logger.get_logger(__name__)

# List of directories in cluster-report
CLUSTER_REPORT_DIRECTORY = ['status', 'logs', 'hostfiles', 'cmds']

# List of files inside cluster-report/status directory.
STATUS_DIR_FILES = ['snat_policy.log', 'snat_localinfo.log',
                    'snat_globalinfo.log',
                    'services_status.log', 'pods_status.log',
                    'ovs_daemonset_status.log', 'host_daemonset_status.log',
                    'get_nodes_status.log',
                    'controller_deployment_status.log',
                    'configmap_snatoperator.log', 'configmap_controller.log',
                    'cluster-info.log', 'configmap_acioperator.log',
                    'configmap_accprovisionoperator.log',
                    'acioperator_deployment_status.log',
                    'get_aci_namespace_status.log',
                    'erspan_policy.log', 'netflow_policy.log',
                    'qos_policy.log', 'node_info.log', 'node_podifs.log',
                    'ipam_details_all_nodes.log', 'network_policy.log']

# List of files inside cluster-report/logs directory.
LOG_DIR_FILES = ['opflex-agent.log', 'mcast-daemon.log',
                 'aci-containers-openvswitch.log', 'aci-containers-host.log',
                 'aci-containers-host-version.log', 'host-ipam.log', 'host-status.log',
                 'host-services.log', 'host-config.log', 'host-endpoints.log']

# List of files inside cluster-report/cmds directory.
CMDS_DIR_FILES = ['agent-version-githash.log', 'ip-r.log',
                  'ovs-ofctl-show-access.log', 'gbp-inspect.log',
                  'ovs-conf-db.log', 'ovs-ofctl-show-int.log',
                  'gbp-unresolved.log', 'ovs-ofctl-dump-flows-access.log',
                  'ovs-vsctl-show.log', 'ip-a.log',
                  'ovs-ofctl-dump-flows-int.log']

# List of Dirs inside cluster-report/hostfiles directory.
HOSTFILES_DIRS = ['opflex-agent-ovs', 'aci-containers']

#List of files which will be empty for Rancher Setup
RANCHER_SETUP_EMPTY_FILES = ['configmap_acioperator.log', 'acioperator.log',
                             'acioperator_deployment_status.log', 'accprovisionoperator.log',
                             'configmap_accprovisionoperator.log']

# List of Dirs inside cluster-report/hostfiles/opflex-agent-ovs directory.
OPFLEX_AGENT_DIRS = ["droplog", "endpoints", "faults", "ids", "mcast",
                     "reboot-conf.d", "services", "snats"]

host_ver = lib.get_aci_containers_host_version()
# startup subdir added in 6.0.4.2
if host_ver >= '6.0.4.2':
    OPFLEX_AGENT_DIRS.append("startup")

# netpols subdir added in 6.1.1.1
if host_ver >= '6.1.1.1':
    OPFLEX_AGENT_DIRS.append("netpols")
LOG.info("Vesrion : %s OPFLEX_AGENT_DIRS %s", host_ver, OPFLEX_AGENT_DIRS)

if host_ver > '6.1.1.1' or (host_ver > '6.0.4.3' and host_ver < '6.1.1.1'):
    # outofband subdir added in 6.1.2.1 and backported to lmr-6.0.4 and mmr-6.1.1 branches
    OPFLEX_AGENT_DIRS.append("outofband")

# List of Dirs inside cluster-report/hostfiles/aci-containers directory.
ACI_CONTAINERS = ["k8s-pod-network"]

# HOSTFILES Dir to Dir mapping
HOSTFILES_DIR_MAPPING = {'opflex-agent-ovs': OPFLEX_AGENT_DIRS,
                         'aci-containers': ACI_CONTAINERS}

# List of files inside cluster-report/logs/controller directory.
LOGS_CONTROLLER_FILE = ['acc.log', 'acc-version.log', 'controller-config.log', 'controller-status.log']

# List of files inside cluster-report/logs/operator directory.
LOGS_OPERATOR_FILE = ['acioperator.log', 'accprovisionoperator.log']

# List of files inside cluster-report/logs/versions directory.
LOGS_VERSIONS_FILE = ['kubectl_version.log']

# Directory to files mapping for directory in cluster-report/logs/
LOGS_EXT_DIR_TO_FILE_MAPPING = {'controller': LOGS_CONTROLLER_FILE,
                                'operator': LOGS_OPERATOR_FILE,
                                'versions': LOGS_VERSIONS_FILE}

if check_chained_mode():
    # OVS, OPFLEX and mcast related file will not get generated in case of chained mode
    LOG_DIR_FILES.remove('aci-containers-openvswitch.log')
    CMDS_DIR_FILES = ['agent-version-githash.log', 'gbp-inspect.log', 'gbp-unresolved.log']
    OPFLEX_AGENT_DIRS.remove('mcast')

# Directory to files mapping for directory in cluster-report.
DIR_TO_FILES_MAPPING = {'status': STATUS_DIR_FILES,
                        'logs': LOG_DIR_FILES,
                        'cmds': CMDS_DIR_FILES,
                        'hostfiles': HOSTFILES_DIRS}


# Container to Directory mapping for directory in cluster-report/pod-logs/
ACI_CONTAINERS = ['aci-containers-controller', 'aci-containers-host',
                  'aci-containers-openvswitch', 'aci-containers-operator']

ACI_CONTAINERS_LOG_DIR_MAPPING = dict()
''' This mapping is dynamically updated below are expected mapping
ACI_CONTAINERS_LOG_DIR_MAPPING = {'aci-containers-controller' :  ['aci-containers-controller'],
                       'aci-containers-host' : ['aci-containers-host', 'mcast-daemon', 'opflex-agent',
                                                'cnideploy'(if use_cnideploy_initcontainer: True )],
                       'aci-containers-openvswitch' : ['aci-containers-openvswitch'],
                       'aci-containers-operator' : ['acc-provision-operator', 'aci-containers-operator']
                      }
'''

SNAT_POLICY_LOG_FILE = {'snat_policy.log', 'snat_localinfo.log',
                        'snat_globalinfo.log'}

FILE_TO_RESOURCE = {'netflow_policy.log': 'netflowpolicy',
                    'erspan_policy.log': 'erspanpolicy',
                    'qos_policy.log': 'qospolicy',
                    'node_podifs.log': 'nodepodifs'}

# skip empty file check for below list of files
SKIP_EMPTY_FILE = {'gbp-unresolved.log'}

SKIP_EMPTY_FILE_OPERATOR = {'configmap_accprovisionoperator.log', 'accprovisionoperator.log'}

# skip empty files of opflex, ovs and operator in case of chained mode
SKIP_EMPTY_NON_CHAINED_MODE_FILE = {'configmap_snatoperator.log', 'ovs_daemonset_status.log',
                                    'node_info.log', 'acioperator_deployment_status.log',
                                    'opflex-agent.log', 'aci-containers-openvswitch.log',
                                    'mcast-daemon.log', 'ovs-ofctl-show-access.log', 'gbp-inspect.log',
                                    'ovs-conf-db.log', 'ovs-ofctl-show-int.log',
                                    'gbp-unresolved.log', 'ovs-ofctl-dump-flows-access.log',
                                    'ovs-vsctl-show.log', 'ovs-ofctl-dump-flows-int.log',
                                    'accprovisionoperator.log', 'acioperator.log',
                                    'agent-version-githash.log'}


def test_acikubectl():
    kapi = KubeAPI()
    hostname = get_ext_router_node_hostname()
    server = SRV_UTILS.get_server_object_by_name(hostname)
    temp_locations = '/tmp/' + lib.generate_random_string(5) + '.tar.gz'
    cmd = "acikubectl debug cluster-report  --output=%s" % temp_locations
    LOG.info("Executing cmd [%s] on node [%s]" % (cmd, hostname))
    server.run(cmd)
    temp_file_saved_location = '/tmp/' + lib.generate_random_string(5)
    server.get(temp_locations, temp_file_saved_location)
    cmd = 'tar -xf %s --directory %s' % (temp_file_saved_location, os.getcwd())
    kapi.exec_cli_cmd(cmd, EXEC_TIMEOUT)
    LOG.info("Validating cluster report output")
    LOG.info("Extracting hostfiles into cluster-report")
    parent_dir = os.getcwd() + '/cluster-report'
    hostfiles_tar = os.getcwd() + '/cluster-report/hostfiles.tar'
    cmd = 'tar -xf %s --directory %s' % (hostfiles_tar, parent_dir)
    kapi.exec_cli_cmd(cmd, EXEC_TIMEOUT)
    podlogs_tar = os.getcwd() + '/cluster-report/pod-logs.tar'
    # Backward compatibility : if pod-logs.tar exists then only verify pod_logs dir
    if os.path.exists(podlogs_tar):
        LOG.info("Extracting pod-logs into cluster-report")
        cmd = 'tar -xf %s --directory %s' % (podlogs_tar, parent_dir)
        kapi.exec_cli_cmd(cmd, EXEC_TIMEOUT)
        CLUSTER_REPORT_DIRECTORY.append('pod-logs')
        DIR_TO_FILES_MAPPING.update({'pod-logs' : get_pod_logs_expected_dir()})

    try:
        verify_cluster_report_dir_structure()
        LOG.info("cluster report output verified successfully.")
    finally:
        delete_generated_dir(server, temp_locations, temp_file_saved_location)


def verify_cluster_report_dir_structure():
    varify_all_cluster_report_directory()
    parent_dir = os.getcwd() + '/cluster-report'
    expected_dir = get_all_nodes_info()
    log_additional_dir = get_logs_ext_directory()
    for path, dir_files in DIR_TO_FILES_MAPPING.items():
        abs_path = parent_dir + "/" + path
        if path != "status" and path != "pod-logs":
            if path == "logs":
                temp_dict = expected_dir.copy()
                temp_dict.extend(log_additional_dir)
                verify_dir(abs_path, temp_dict)
            else:
                verify_dir(abs_path, expected_dir)
        LOG.info("Validating directory [%s] in cluster report." % path)
        if path == "hostfiles":
            verify_hostfiles_dirs(abs_path, dir_files)
        elif path == "pod-logs":
            verify_pod_logs_dirs(abs_path, dir_files)
        else:
            verify_dir_files(abs_path, dir_files)
        LOG.info("Directory [%s] validated successfully." % path)


def get_logs_ext_directory():
    """Returns directory list apart from node directories."""
    res = list()
    for logs_ext_dir in LOGS_EXT_DIR_TO_FILE_MAPPING.keys():
        res.append(logs_ext_dir)
    return res


def varify_all_cluster_report_directory():
    """Check existance of directory inside cluster report."""
    path = os.getcwd() + '/cluster-report'
    dir = lib.get_dir_from_dir(path)
    assert set(dir) == set(CLUSTER_REPORT_DIRECTORY), ('Directory'
        ' %s  missing in cluster-report, cluster-report: %s' % ((set(
            CLUSTER_REPORT_DIRECTORY) - set(dir)),
            show_cluster_report_details()))


def verify_hostfiles_dirs(path, dir_files):
    dir_list = lib.get_dir_from_dir(path)
    for dir in dir_list:
        dpath = path + "/" + dir
        verify_dir(dpath, HOSTFILES_DIRS)
        verify_hostfiles_inner_dir(dpath)


def verify_hostfiles_inner_dir(path):
    for p, dirs in HOSTFILES_DIR_MAPPING.items():
        dpath = path + "/" + p
        verify_dir(dpath, dirs)


def verify_dir_files(path, dir_files):
    """Validate files and directory inside cluster report directory."""
    dir = lib.get_dir_from_dir(path)
    files = lib.get_files_from_dir(path)
    is_file_empty(files, path)
    for dir in dir:
        if dir in LOGS_EXT_DIR_TO_FILE_MAPPING.keys():
            temp_path = path + '/' + dir
            verify_dir_files(temp_path, LOGS_EXT_DIR_TO_FILE_MAPPING.get(dir))
        else:
            temp_path = path + '/' + dir
            verify_dir_files(temp_path, dir_files)
    if files:
        assert set(files) == set(dir_files), ('File list [%s] missing in '
            'directory [%s]' % ((set(dir_files) - set(files)), path))


def verify_dir(path, expected_dir):
    """Verify existence of directory in given path."""
    dir_list = lib.get_dir_from_dir(path)
    assert set(dir_list) == set(expected_dir), ('Directory list [%s] missing '
        'in directory [%s] ' % ((set(expected_dir) - set(dir_list)), path))


def get_ext_router_node_hostname():
    """Returns hostname of manager node."""
    nodes_info = SRV_UTILS.load_nodes_information()
    for node in nodes_info.get('external_router_nodes', []):
        return node['hostname']


def get_all_nodes_info():
    """Returns hostname of all the nodes i.e (manager and worker)."""
    res = list()
    node_info = SRV_UTILS.load_nodes_information()
    for node in (node_info['manager_nodes']
                 + node_info.get('worker_nodes', [])):
        res.append("node-" + node['hostname'])
    return res


def delete_generated_dir(server, dir_location, local_dest):
    """Delete generated directories and files."""
    try:
        cmd = "rm -rf %s" % dir_location
        server.run(cmd)
        os.remove(local_dest)
        shutil.rmtree(os.getcwd() + '/cluster-report')
    except Exception as err:
        LOG.warning("Error occurred while deleting temp files, error: %s" % err)


def is_snatpolicy_applied():
    if check_chained_mode():
        return False
    kapi = KubeAPI()
    cmd = "kubectl get snatpolicy"
    return kapi.exec_cli_cmd(cmd)


def get_resource(resource):
    if check_chained_mode():
        return False
    kapi = KubeAPI()
    cmd = "kubectl get %s --all-namespaces" % resource
    return kapi.exec_cli_cmd(cmd)


def get_all_configmap():
    cm, kapi = list(), KubeAPI()
    cm_info = kapi.get_detail("configmap",
                              namespace="aci-containers-system")
    for cmap in cm_info.get('items'):
        cm.append(cmap['metadata']['name'])
    LOG.info("configmap list: %s" % cm)
    return cm


def is_accprovisionoperator_applied():
    cm_list = get_all_configmap()
    return True if "acc-provision-config" in cm_list else False


def is_file_empty(file_list, path):
    """Check if provided file is empty."""
    for f_name in file_list:
        if verify_skip_condition(f_name):
            continue
        file_path = path + '/' + f_name
        if os.stat(file_path).st_size == 0:
            assert False, ('file [%s] is empty' % file_path)


def verify_skip_condition(f_name):
    if f_name in SKIP_EMPTY_FILE:
        return True
    if f_name in SKIP_EMPTY_FILE_OPERATOR and (
        lib.is_acc_provision_operator_excluded() or not is_accprovisionoperator_applied()):
        return True
    if f_name in SNAT_POLICY_LOG_FILE and not is_snatpolicy_applied():
        return True
    if check_chained_mode() and f_name in SKIP_EMPTY_NON_CHAINED_MODE_FILE:
        return True
    if f_name in FILE_TO_RESOURCE.keys() \
            and not get_resource(FILE_TO_RESOURCE[f_name]):
        return True
    if f_name in RANCHER_SETUP_EMPTY_FILES and lib.is_rke1_setup():
        return True
    return False


def cmd_exists(cmd):
    return shutil.which(cmd) is not None


def show_cluster_report_details():
    """Displays files and directories available in cluster report."""
    files = list()
    directories = list()
    path = os.getcwd() + '/cluster-report'
    for (dirpath, dirnames, filenames) in os.walk(path):
        for f in filenames:
            files.append('%s' % os.path.join(dirpath, f))
        for d in dirnames:
            directories.append('%s' % os.path.join(dirpath, d))
    LOG.info("Showing cluster report's files: [%s] and "
             "directories : [%s]" % (files, directories))


def get_pod_logs_expected_dir():
    """Returns expected root directories list for pod-logs directory"""
    aci_namespace = lib_helper.get_aci_namespace()
    LOG.info("ACI namespace : %s" % aci_namespace)
    exp_dir_list = list()
    # Get all pod details with label aci-containers-[controller|host|openvswitch|operator] on aci_namespace
    for label in ACI_CONTAINERS:
        pod_label = 'name=%s' % label
        pods = lib.get_pod_detail(pod_label, name=None, namespace=aci_namespace)
        if len(pods['items']) == 0:
            LOG.info("No pod found with label %s" % pod_label)
            continue
        expected_sub_dir = get_pod_containers_name(pods['items'][0])
        ACI_CONTAINERS_LOG_DIR_MAPPING.update({label : expected_sub_dir})
        for pod in pods['items']:
            # Format : <namespace>_<pod_name>_<poduid>
            dir_name = aci_namespace + '_' + pod['metadata']['name'] + '_' + pod['metadata']['uid']
            exp_dir_list.append(dir_name)

    LOG.info(ACI_CONTAINERS_LOG_DIR_MAPPING)
    return exp_dir_list

def get_pod_containers_name(pod):
    """Get all the containers running on pod """
    expected_sub_dir = list()
    # if use_cnideploy_initcontainer: True we will have initContainer
    init_container_status  = pod['status'].get('initContainerStatuses', [])

    for container_status in pod['status']['containerStatuses'] + init_container_status:
        if container_status['name'] not in expected_sub_dir:
            expected_sub_dir.append(container_status['name'])
    return expected_sub_dir
          
def get_pod_logs_expected_sub_dirs(dir_name):
    """Returns expected sub directories list for pod-logs/root directory"""
    for container, exp_sub_dir in ACI_CONTAINERS_LOG_DIR_MAPPING.items():
        if container in dir_name:
            return exp_sub_dir
    return []


def verify_pod_logs_dirs(path, dir_list):
    verify_dir(path, dir_list)
    # verify pod-logs sub dirs
    for dir_name in dir_list:
        abs_path = path + "/" + dir_name
        exp_sub_dir = get_pod_logs_expected_sub_dirs(dir_name)
        verify_dir(abs_path, exp_sub_dir)

